[ TODO ]
encryption on a per message basis not possible since key
will be encrtyped too
 -> switch encryption mode: must include the seed
 -> replay attack: should be done in 2 message
  (original then copy)
 -> use 2 messages


[ general ]

bano (base node) protocol

the nodes must be kept as simple as possible, to allow cheap.
think about a simple relay activation node
the master is considered resourceful. any feature that can be
implemented on the master to decrease the node resources
requirments should be.

[ transport layer ]

bano aims at being independent from the physical layer and
limits the constraints put on the physical layer and its
protocol. bano requires:
. a packet based transport layer
. if provided by hardware, addressing must be at least 4
bytes. otherwise, addressing is implement in software and
the payload size must be increased by 4 bytes.
. crc must be at least 2 bytes. can be implemented in sw.
. data payload size must be at least 8 bytes, but depends
on what is implemented in software
. no packet ordering is assumed
. no packet acknowledgement is assumed

the physical layer can work in all the commonly used wireless
ranges (433, 868, 915 MHz and 2.4 GHz).

2 chipsets are considered:
. NRF905
. NRF24L01P

in the above chipsets, the main differences are the addressing
scheme length (4 bytes max for NRF905, 5 bytes for NRF24L01P).


[ addressing ]

the base has a fixed address

when a node joins a network, a node has a default BANO_ADDR_ANY
address. it sends the base a request:
BANO_OP_GET, BANO_KEY_ADDR, random_id[4]
the base allocates a new address, and reply with:
BANO_OP_SET, BANO_KEY_ADDR, random_id[4], addr

to enumerate the nodes, a base


[ messaging ]

in RX mode, a node receive logic consumes power. to reduce power
consumption and avoid being, a node can poll the requests by
sending a request:
BANO_OP_GET, BANO_KEY_REQ, node_addr
the base must then send requests for this node in a short time
lapse, and the node will then return to reduced power mode at
completion.
also, note the polling scheme prevents a malicious sender to
keep transmitting to a node in order to reduce its battery life.


[ message integrity ]

the integrity is handled by hardware via a 2 bytes checksum.


[ message acknowledgment ]


[ keys ]

system capabilities
. security scheme

connectivity testing
. ping the master

alert reporting


[ api ]

refer to bano.h


[ on the assumption base is always present before nodes ]

A scenario where the user powers a node before powering the
base is largely possible. Handshaking .

Also, the base could be powered

Also, completely passive nodes (ie. alarm) does not anounce
themselves when powered up.

Thus, the base is not assumed to be present when a node is
added to the network.

(or base cannot assume base was present at the time
they do). Thus, there must be a mechanism to convey every
required information in one message.

Designing the protocol this way will increase



[ on message identification ]


[ on message forwarding ]


[ on security ]

Implementing security adds complexity not required by the common
case, and goes against some other BANO protocol design choices
(stateless, common case, short message size). However, it is
undeniable that there are node messages that require some or all
of the following security features:
. hiding message contents
. preventing replay attack
. preventing brute force
. preventing tampering attacks (mim ...)
. detecting flood
. node DOS

[[ message contents hiding ]]
Per symetric block ciphers can be used to hide message contents.
The ciphers rely on a shared secret key. Proposed ciphers:
. AES 128 bits

[[ preventing replay attack ]]
The usual way to prevent replay attack is for the node to
convey a seed. This seed must not be known by the attacker
at the time the message is generated.

example: shutting down an alarm
An attacker may replay a previously capture message used to
unlock an alarm, even if encrypted. If the message contains
a time dependent information that can be checked by the base,
then any previously generated message will no longer be valid.
The time dependent information should be generated randomly
in a fashion not known by the attacker. For instance, a seed
can be generated locally by the base and sent encrypted to
the node.

[[ preventing brute force ]]

[[ preventing tampering attacks (mim ...) ]]

[[ detecting node flood ]]
flood can be used or to prevent a node from speaking with
the base.


. security token
-> the whole message is readable, a secret key based seed is
used to validate the security
-> less computing required to decrypt the message

. security seed broadcast
-> the master (node?) broadcasts a seed at regular interval
his security seed is used in the encryption token scheme
-> if the node broadcast, it must be able to generate it, which
means random number generation caps
-> if the master broadcast it, the node has to store it

=> any failed attempt to check the security token should
renegotiate the node security context

flooding
detection
replay
encryption


[ frame layout ]
op:2
flags:6
saddr:32
key:16
val:32
checksum: 16

--
security:16

--
ordering:8


[ TODO: review existing protocols ]
